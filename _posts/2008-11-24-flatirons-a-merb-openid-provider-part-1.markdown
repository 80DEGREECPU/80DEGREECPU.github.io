--- 
wordpress_id: 80
layout: post
title: "Flatirons : A Merb OpenID Provider Part 1"
wordpress_url: http://atmos.org/?p=80
---
<p><a href="http://www.powerset.com/explore/semhtml/Flatirons?query=what+are+the+flatirons">What are the flatirons</a> you say?  They're a rock formation near my house in Colorado, they look like this in the winter.  
<a class="tt-flickr tt-flickr-Medium" href="http://flickr.com/photos/molas/62517813"><img class="alignnone" src="http://farm1.static.flickr.com/31/62517813_0d49863e68.jpg" alt="" width="465" height="167" /></a>
It's also the name of the open source merb 1.0 based OpenID <strong>Provider</strong> that's <a href="http://github.com/atmos/flatirons/tree/master">available on github</a>.  We recently started rolling out a customized OpenID <strong>Provider</strong> for all of our internal apps.  Flatirons was how I familiarized myself with the OpenID <a href="http://openid.net/specs/openid-authentication-2_0.html">spec</a>.</p>
<h1>The Low Down</h1>
I'm going to break this into two parts, one on the OpenID <strong>Provider</strong> and one on the way we're testing in merb 1.0.  There appears to be a lack of examples on writing specs in the merb 1.0 world and I assure you it rocks way more than it used to.  This part will give you a brief overview of what's really involved in the OpenID protocol.  Part 2 will cover testing the spec that's described here.
<h1>Paint a Perfect Picture</h1>
It's not perfect, but it should give you an idea about the request/response life cycle for an OpenID Authentication.  Keep in mind that <strong>User-Agent</strong> in these diagrams is normally a User's browser.  A <strong>Consumer</strong> is your new micro-app that doesn't even have a concept of user passwords.  The <strong>Provider</strong> is where flatirons comes into play, it's the OpenID to Merb layer that allows you to take advantage of merb-auth's strategies.  The <strong>Auth Backend</strong> is trivial to customize, consult the <a href="http://github.com/wycats/merb/tree/master/merb-auth">merb-auth</a> docs for more info.  Check it:
<a class="tt-flickr tt-flickr-Original" href="http://atmos.org/photos/photo/3054931483/flatirons.html"><img class="aligncenter" src="http://farm4.static.flickr.com/3036/3054931483_b2d220624a.jpg" alt="flatirons" width="465" height="500" /></a>
<h1>Identity Discovery</h1>
<p>Identity Discovery is the first part of the <strong>User-Agent</strong> authentication.  The <strong>Consumer</strong> can request one of three options(<a href="http://openid.net/specs/openid-authentication-2_0.html#discovery">the spec</a>) but normally the <strong>Provider</strong> sends back a Yadis document that lets the <strong>Consumer</strong> know where to go to start talking that crypto shit with the <strong>Provider</strong>.  This is normally in the form of an xrds+xml response.</p>
<h1>Associate</h1>
<p>This is where the magic starts.  "An association between the Relying Party and the OpenID Provider establishes a shared secret between them, this is used to verify subsequent protocol messages and reduce round trips."(<a href="http://openid.net/specs/openid-authentication-2_0.html#associations">the spec</a>)  The <strong>Consumer</strong> and the <strong>Provider</strong> negotiate some Diffie-Hellman keys and use these for communicating for the rest of the auth life-cycle.</p>
<h1>Check ID Setup</h1>
<p>Check ID Setup covers a few things, there's a few modes that you should really investigate in the <a href="http://openid.net/specs/openid-authentication-2_0.html#requesting_authentication">documentation</a> if you're curious.  Suffice it to say there's two interesting modes that are a part of the id setup, <strong>checkid_setup</strong> and <strong>immediate</strong>.  <strong>Immediate</strong> is used less frequently and it's designed for authenticating in a manner that isn't interactive(think ajax logins).  The <strong>checkid_setup</strong> mode is way more common, it involves normal http requests, redirects, and pages where you enter your username and password.</p>
<h1>Acceptance - "Do you trust me?"</h1>
<p>Acceptance is a form on the <strong>Provider</strong> displaying the specific information it's going to send to the <strong>Consumer</strong>.  The <strong>User-Agent</strong> specifies whether or not this information is OK to send to the <strong>Consumer</strong>.  Normally users just click OK here but this is where a full fledged <strong>Provider</strong> allows you to pick one of many identities you have stored there.</p>
<h1>Identity Result</h1>
<p>Once the <strong>User-Agent</strong> accepts the <strong>Provider</strong> as a trusted source, an identity result is sent back to the <strong>Consumer</strong> from the <strong>Provider</strong>.  The <strong>Consumer</strong> can then take this response and do whatever local bootstrapping they need to for the user.  OpenID can send back more than just the identity URL, but flatirons doesn't take advantage of these spec extensions yet.</p>
<h1>WTF, Why do I even care?</h1>
<p>Since this is based on <strong>merb-auth</strong>, you have all of the strategies it provides at your disposal.  Flatirons defaults to the salted password setup, but you could easily hook this into whatever authentication backend that you need.  If you're considering Ruby applications and need single sign on then this is a good starting point regardless of your user store.  In a trusted environment you can make this even more simple, whitelisting can simplify the request/response life-cycle by removing the <strong>Acceptance</strong> step.  Depending on your user store you can mask the interaction with the actual identity URL.  We're able to mask the concept of the identity url a <strong>User-Agent</strong> uses and we just ask them for their email address.  Ours users don't even know what OpenID is, it rocks.</p>

<h1>Where's the Code</h1>
<p><a href="http://github.com/atmos/flatirons">It's on github of course.</a>.  In the next couple of days I'll dissect the specs that validate the expectations defined above.</p>
